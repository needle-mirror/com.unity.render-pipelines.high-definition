#pragma kernel BuildDispatchIndirect        BUILDINDIRECT=BuildDispatchIndirect         IS_DRAWINSTANCEDINDIRECT=0
#pragma kernel BuildDrawInstancedIndirect   BUILDINDIRECT=BuildDrawInstancedIndirect    IS_DRAWINSTANCEDINDIRECT=1
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"

#if PLATFORM_THREAD_GROUP_OPTIMAL_SIZE
#define NR_THREADS              PLATFORM_THREAD_GROUP_OPTIMAL_SIZE  // use platform optimal thread group size if possible
#else
#define NR_THREADS              64                                  // default to 64 threads per group on other platforms..
#endif

RWBuffer<uint> g_DispatchIndirectBuffer : register( u0 );   // Indirect arguments have to be in a _buffer_, not a structured buffer
RWStructuredBuffer<uint> g_TileList;
StructuredBuffer<uint> g_TileFeatureFlags;

uniform uint g_NumTiles;
uniform uint g_NumTilesX;

[numthreads(NR_THREADS, 1, 1)]
void BUILDINDIRECT(uint dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId >= g_NumTiles)
        return;

    uint featureFlags = g_TileFeatureFlags[dispatchThreadId];

    uint tileY = (dispatchThreadId + 0.5f) / (float)g_NumTilesX;    // Integer division is extremely expensive, so we better avoid it
    uint tileX = dispatchThreadId - tileY * g_NumTilesX;

    // Check if there is no material (means it is a sky/background pixel).
    // Note that we can have no lights, yet we still need to render geometry with precomputed illumination.
    if ((featureFlags & MATERIAL_FEATURE_MASK_FLAGS) != 0)
    {
        uint variant = FeatureFlagsToTileVariant(featureFlags);
        uint offset;

#if IS_DRAWINSTANCEDINDIRECT
        // We are filling up an indirect argument buffer for DrawInstancedIndirect.
        InterlockedAdd(g_DispatchIndirectBuffer[variant * 4 + 1], 1, offset);
#else
        // We are filling up an indirect argument buffer for DispatchIndirect.
        InterlockedAdd(g_DispatchIndirectBuffer[variant * 3 + 0], 1, offset);
#endif

        g_TileList[variant * g_NumTiles + offset] = (tileY << 16) | tileX;
    }
}
