// We need 2 bounces given that we want to see the direct lighting of the reflected surfaces
#pragma max_recursion_depth 1

// HDRP include
#define SHADER_TARGET 50
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

// The target acceleration structure that we will evaluate the reflexion in
Texture2D<float>			          	_StencilTexture;
Texture2D<float>						_DepthTexture;

// Flag value that defines if a given pixel recieves reflections or not
// int   									_SsrStencilExclusionValue;

// Output structure of the reflection raytrace shader
RWTexture2D<float4> 					_SsrLightingTextureRW;

[shader("miss")]
void MissShaderReflections(inout RayIntersection rayIntersection : SV_RayPayload)
{
	rayIntersection.color = SAMPLE_TEXTURECUBE_ARRAY_LOD(_SkyTexture, s_trilinear_clamp_sampler, rayIntersection.incidentDirection, 0.0f, 0);
}

[shader("raygeneration")]
void RayGenReflections()
{
	uint2 LaunchIndex = DispatchRaysIndex();
    uint2 LaunchDim = DispatchRaysDimensions();

	// Pixel coordinate of the current pixel
    uint2 currentPixelCoord = uint2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1);
    _SsrLightingTextureRW[currentPixelCoord] = float4(0.0f, 0.0f, 0.0f, 0.0f);
	
    /*
    // Read the stencil value of the pixel
    uint stencilVal = UnpackByte(LOAD_TEXTURE2D(_StencilTexture, currentPixelCoord).r);
    
    // Check if this pixel should not recieve ssr, for the moment we compute it for everyone
    bool doesntReceiveSSR = (stencilVal & _SsrStencilExclusionValue) != 0;
    if (doesntReceiveSSR)
    {
        return;
    }
	*/

	// Read the depth value
	float depthValue  = _DepthTexture[currentPixelCoord];
	if(depthValue == 0.0f)
		return;

	// Convert this to a world space position
	PositionInputs posInput = GetPositionInput(currentPixelCoord, 1.0/LaunchDim.xy, depthValue, _InvViewProjMatrix, _ViewMatrix, 0);
	float distanceToCamera = length(posInput.positionWS);
	posInput.positionWS = GetAbsolutePositionWS(posInput.positionWS);

	// Compute the incident vector on the surfaces
	float3 incidentWS = normalize(posInput.positionWS - _WorldSpaceCameraPos);
	
	// Decode the world space normal
    NormalData normalData;	
    DecodeFromNormalBuffer(currentPixelCoord, normalData);
	
    // Create the local ortho basis
	float3 b1, b2;
	CreatePixarOrthoNormalBasis(normalData.normalWS, b1, b2);

	// Compute the actual roughness
	float roughness = PerceptualRoughnessToRoughness(normalData.perceptualRoughness);

	// the number of samples based on the roughness
	int numSamples = lerp(1, _RaytracingNumSamples, sqrt(normalData.perceptualRoughness));

	// Variable that accumulate the radiance
	float3 finalColor = float3(0.0, 0.0, 0.0);

	// Let's loop through th e samples
	for(int i = 0; i < numSamples; ++i)
	{
		// Get the following noise value
    	float2 noiseValue = GetRaytracingNoiseSample(currentPixelCoord, i);

    	// Importance sample the direction
	    float3 sampleDir = SampleGGXDir(noiseValue, roughness);

	    // Move the direction to world space
	    sampleDir = sampleDir.x * b1 + sampleDir.y * b2 + sampleDir.z * normalData.normalWS;

	    // Compute the reflected direction
	    float3 reflectDir = reflect(incidentWS, sampleDir);

		// Create the ray descriptor for this pixel
		RayDesc rayDescriptor;
		rayDescriptor.Origin = posInput.positionWS + normalData.normalWS * _RaytracingRayBias;
		rayDescriptor.Direction = reflectDir;
		rayDescriptor.TMin = 0;
		rayDescriptor.TMax = _RaytracingRayMaxLength;

		// Create and init the RayIntersection structure for this
		RayIntersection rayIntersection;
		rayIntersection.color = float3(0.0, 0.0, 0.0);
		rayIntersection.incidentDirection = rayDescriptor.Direction;
		rayIntersection.origin = rayDescriptor.Origin;
		rayIntersection.t = 0.0f;

		// In order to achieve filtering for the textures, we need to compute the spread angle of the pixel
		rayIntersection.cone.spreadAngle = _PixelSpreadAngle;
		rayIntersection.cone.width = distanceToCamera * _PixelSpreadAngle;
		
		// Evaluate the ray intersection
		TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDescriptor, rayIntersection);
		
		// Accumulate this value
		finalColor += rayIntersection.color;
	}

	// Normalize the radiance
	finalColor /= (float)numSamples;

	// Alright we are done :D
    _SsrLightingTextureRW[currentPixelCoord] = float4(finalColor, 1.0f);
}

[shader("closesthit")]
void ClosestHitMain(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
{   
	// When we do not hit any known closest hit, that means that no shader was specified for the target object meaning either it has nothing to do in the acceleration structure or we need to add raytracing subshaders to it
	rayIntersection.color = float3(1.0, 0.0, 0.5);
}
