// We need 2 bounces given that we want to see the direct lighting of the reflected surfaces
#pragma max_recursion_depth 1

// HDRP include
#define SHADER_TARGET 50
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

// The target acceleration structure that we will evaluate the reflexion in
Texture2D<float>			          	_StencilTexture;
Texture2D<float>						_DepthTexture;

// Flag value that defines if a given pixel recieves reflections or not
// int   									_SsrStencilExclusionValue;

// Output structure of the reflection raytrace shader
RWTexture2D<float4> 					_AmbientOcclusionTextureRW;
RWTexture2D<float> 						_RaytracingHitDistanceTexture;
RWTexture2D<float4> 					_RaytracingVSNormalTexture;

[shader("miss")]
void MissShaderAmbientOcclusion(inout RayIntersection rayIntersection : SV_RayPayload)
{
	rayIntersection.color += float3(1.0f, 1.0f, 1.0f);
}

[shader("raygeneration")]
void RayGenAmbientOcclusion()
{
	uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

	// Pixel coordinate of the current pixel
    uint2 currentPixelCoord = uint2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1);
    _AmbientOcclusionTextureRW[currentPixelCoord] = float4(0.0f, 0.0f, 0.0f, 0.0f);
	
    /*
    // Read the stencil value of the pixel
    uint stencilVal = UnpackByte(LOAD_TEXTURE2D(_StencilTexture, currentPixelCoord).r);
    
    // Check if this pixel should not recieve ssr, for the moment we compute it for everyone
    bool doesntReceiveSSR = (stencilVal & _SsrStencilExclusionValue) != 0;
    if (doesntReceiveSSR)
    {
        return;
    }
	*/

	// Read the depth value
	float depthValue  = _DepthTexture[currentPixelCoord];
	if(depthValue == 0.0f)
		return;

	// Convert this to a world space position
	PositionInputs posInput = GetPositionInput(currentPixelCoord, 1.0/LaunchDim.xy, depthValue, _InvViewProjMatrix, _ViewMatrix, 0);
	posInput.positionWS = GetAbsolutePositionWS(posInput.positionWS);

	// Decode the world space normal
    NormalData normalData;	
    DecodeFromNormalBuffer(currentPixelCoord, normalData);
	
	// the number of samples based on the roughness
	int numSamples = _RaytracingNumSamples;

	// Variable that accumulate the radiance
	float3 completeColor = float3(0.0, 0.0, 0.0);

	// Minimal distance of the intersection
	float minDistance = _RaytracingRayMaxLength;

	// Let's loop through th e samples
	for(int i = 0; i < numSamples; ++i)
	{
		// Get the following noise value
    	float2 noiseValue = GetRaytracingNoiseSample(currentPixelCoord, i);

    	// Importance sample the direction
	    float3 sampleDir = SampleHemisphereCosine(noiseValue.x, noiseValue.y, normalData.normalWS);
		
		// Create the ray descriptor for this pixel
		RayDesc rayDescriptor;
		rayDescriptor.Origin = posInput.positionWS + normalData.normalWS * _RaytracingRayBias;
		rayDescriptor.Direction = sampleDir;
		rayDescriptor.TMin = 0;
		rayDescriptor.TMax = _RaytracingRayMaxLength;

		// Create and init the RayIntersection structure for this
		RayIntersection rayIntersection;
		rayIntersection.color = float3(0.0, 0.0, 0.0);
		rayIntersection.incidentDirection = rayDescriptor.Direction;
		rayIntersection.origin = rayDescriptor.Origin;
		rayIntersection.t = 0.0f;

		// Evaluate the ray intersection
		TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_FORCE_NON_OPAQUE | RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDescriptor, rayIntersection);
		
		// combine
		if(rayIntersection.t > 0.0f)
		{
			minDistance = min(minDistance, rayIntersection.t);
		}

		// Accumulate this value
		completeColor += rayIntersection.color;
	}

	// Normalize the radiance
	completeColor /= (float)numSamples;

	// Alright we are done
    _AmbientOcclusionTextureRW[currentPixelCoord] = float4(1.0f - completeColor, 1.0f);
    _RaytracingHitDistanceTexture[currentPixelCoord] = minDistance;
    float3 normalWS = mul(unity_MatrixInvV, float4(normalData.normalWS, 0.0f)).xyz;
    _RaytracingVSNormalTexture[currentPixelCoord] = float4(normalWS, 1.0f);
}

// Fallback default any hit shader for this raytrace shader
[shader("anyhit")]
void AnyHitMain(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
{
    rayIntersection.color = float3(0.0, 0.0, 0.0);
    AcceptHitAndEndSearch();
}
